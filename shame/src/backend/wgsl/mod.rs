use crate::{
    backend::code_write_buf::{CodeWriteBuf, CodeWriteSpan},
    common::pool::{Key, PoolRef},
    frontend::{
        any::shared_io::{BindPath, BindingType, BufferBindingType},
        encoding::{EncodingError, EncodingErrorKind},
    },
    ir::{
        self,
        expr::{Expr, Show},
        ir_type::StructDef,
        pipeline::{PipelineKind, ShaderStage, StageMask, WipBinding, WipPushConstantsField},
        recording::{
            AllocStmt, AtomicCompareExchangeWeakGenerics, Block, BlockKind, CallInfo, Context, Control, ExprStmt,
            FinalIdents, FlowStmt, FrexpGenerics, FunctionDef, Ident, Jump, MemoryRegion, ModfGenerics, Stmt,
            TemplateStructParams,
        },
        AccessMode, AddressSpace, HandleType, Node, StoreType, Type,
    },
};
use std::{fmt::Write, process::Output, rc::Rc};
use thiserror::Error;
mod error;
mod syntax_highlight;
mod write_builtin_templates;
mod write_node;
mod write_shader_io;
mod write_texture_format;
mod write_type;
pub use error::WgslErrorKind;

pub use syntax_highlight::syntax_highlight_wgsl;
use write_builtin_templates::write_builtin_template_wrapper_functions;
use write_node::{get_single_arg, is_guaranteed_valid_as_statement, write_node};
pub(crate) use write_texture_format::wgsl_builtin_texture_format_repr;

use self::{
    error::{WgslError, WgslErrorLevel},
    write_node::{write_binding_ident, write_node_by_key, write_node_type_by_key},
    write_shader_io::write_shader_entry_point_and_io_defs,
    write_type::{address_space_var_qualifier_str, write_sized_type, write_store_type, write_type},
};

use super::{shader_code::ShaderCode, shader_context::ShaderContext};

type WgslContext<'a> = ShaderContext<'a, WgslInfo>;

struct WgslInfo {}

pub fn generate_shader(ctx: &Context, idents: FinalIdents) -> Result<ShaderCode, EncodingError> {
    let mut ctx = WgslContext::new(ctx, idents, WgslInfo {});
    let mut code_buf = CodeWriteBuf::new();
    {
        let mut code = code_buf.span(ctx.ctx.first_user_caller());
        write_shader(&mut code, &ctx).map_err(|err| err.into_encoding_err(&ctx))?;
    }

    let code = code_buf.finish();
    Ok(code)
}

fn write_shader(code: &mut CodeWriteSpan, ctx: &WgslContext) -> Result<(), WgslError> {
    const VERSION: &str = env!("CARGO_PKG_VERSION");
    writeln!(code, "// generated by `shame` {VERSION}")?;
    writeln!(code, "diagnostic(warning, derivative_uniformity);");
    write_module_scope(code, ctx)?;
    match ctx.ctx.pipeline_kind() {
        PipelineKind::Render => {
            write_shader_entry_point_and_io_defs(code, ShaderStage::Vert, ctx)?;
            write_shader_entry_point_and_io_defs(code, ShaderStage::Frag, ctx)?;
        }
        PipelineKind::Compute => {
            write_shader_entry_point_and_io_defs(code, ShaderStage::Comp, ctx)?;
        }
    }
    Ok(())
}

fn write_module_scope(code: &mut CodeWriteSpan, ctx: &WgslContext) -> Result<(), WgslError> {
    for def in ctx.ctx.struct_registry().iter_topo_sorted() {
        write_struct_definition(code, def, ctx)?;
    }

    {
        let pipe_layout = ctx.ctx.pipeline().layout.borrow();
        for (bind_path, binding) in &pipe_layout.bindings {
            write_binding_def(code, bind_path, binding, ctx)?;
        }
        write_push_constant_var_def(code, &pipe_layout.push_constants, ctx)?;
    }

    for (template_params, instantiated_struct) in ctx.ctx.pipeline().builtin_template_structs.borrow().instantiations()
    {
        write_builtin_template_wrapper_functions(code, template_params, instantiated_struct, ctx)?;
    }

    for region in &ctx.non_fn_allocations {
        write_module_scope_var_definition(code, region, ctx)?;
    }

    for def in ctx.ctx.pool::<FunctionDef>().iter() {
        write_fn_def(code, def, ctx)?;
    }
    Ok(())
}

fn write_module_scope_var_definition(
    code: &mut CodeWriteSpan,
    region: &Rc<MemoryRegion>,
    ctx: &WgslContext,
) -> Result<(), WgslError> {
    let call_info = region.call_info;
    let mut code = code.sub_span(call_info);
    match region.ident {
        Some(ident) => {
            let (addr_space, ty, access) = (region.address_space, &region.ty, region.allowed_access);

            if let Some(addr_str) = address_space_var_qualifier_str(addr_space, call_info)? {
                write!(&mut code, "var<{addr_str}")?;
                let access_str = match access {
                    AccessMode::ReadWrite => "read_write",
                    AccessMode::Read => "read",
                    _ => {
                        return Err(
                            WgslErrorKind::AccessModeNotSupportedByAddressSpace(access, addr_space).at(call_info)
                        );
                    }
                };
                if let AddressSpace::Storage = addr_space {
                    write!(&mut code, ", {}", access_str)?
                }
                writeln!(&mut code, "> {}: ", &ctx.idents[ident])?;
                write_store_type(&mut code, ty, call_info, ctx)?;
                writeln!(&mut code, ";")?;
            }
            Ok(())
        }
        None => Err(WgslErrorKind::AllocationHasNoIdent(region.clone())
            .at_level(call_info, WgslErrorLevel::InternalPleaseReport)),
    }
}

fn write_block_by_key(
    code: &mut CodeWriteSpan,
    key: Key<Block>,
    stage_filter: StageMask,
    ctx: &WgslContext,
) -> Result<(), WgslError> {
    write_block(code, &ctx.ctx.pool()[key], stage_filter, ctx)
}

fn write_block(
    code: &mut CodeWriteSpan,
    block: &Block,
    stage_filter: StageMask,
    ctx: &WgslContext,
) -> Result<(), WgslError> {
    let indent = ctx.indent.current();
    let mut code = code.sub_span(block.call_info);
    let has_braces = matches!(block.kind, BlockKind::Body(_));
    let one_line_per_stmt = matches!(block.kind, BlockKind::Body(_) | BlockKind::EntryPoint);
    let suffix = match one_line_per_stmt {
        true => ";",
        false => "",
    };
    if has_braces {
        writeln!(code, "{{")?
    }
    {
        let indent = if has_braces {
            indent.deeper()
        } else {
            ctx.indent.current()
        };
        for (i, (stmt, time, call_info)) in block.stmts.iter().enumerate() {
            let is_last = i == block.stmts.len();

            if stmt.stages_cloned(ctx.ctx).is_present(stage_filter) {
                if one_line_per_stmt {
                    let code = &mut code.sub_span(*call_info);
                    write!(code, "{indent}")?;
                    write_stmt(code, stmt, suffix, *call_info, ctx)?;
                    writeln!(code)?;
                } else {
                    write_stmt(&mut code, stmt, suffix, *call_info, ctx)?;
                }
            }
        }
    }
    if has_braces {
        if one_line_per_stmt {
            write!(code, "{indent}")?
        }
        write!(code, "}}")?
    }
    Ok(())
}

fn write_stmt(
    code: &mut CodeWriteSpan,
    stmt: &Stmt,
    suffix: &str,
    call_info: CallInfo,
    ctx: &WgslContext,
) -> Result<(), WgslError> {
    let indent = ctx.indent.current();
    let code = &mut code.sub_span(call_info);
    match stmt {
        Stmt::Expr(e) => match e {
            ExprStmt::Expr(node_key_) => {
                let mut node_key = *node_key_;
                // WGSL has no such thing as an `expr` statement,
                // therefore we may create phony assignments here or fail with an internal error
                let nodes = ctx.ctx.pool();
                let mut node = &nodes[node_key];

                // special case for Expr::Show, since it is basically the inner expression that is relevant here
                if let Expr::Show(Show) = node.expr {
                    write!(code, "/*show:*/")?;
                    // use the arg instead
                    node_key = get_single_arg(node)?;
                    node = &nodes[node_key];
                }

                let call_info = node.call_info;
                let standalone_expr_possible = is_guaranteed_valid_as_statement(&node.expr);

                if node.ident.is_none() && is_guaranteed_valid_as_statement(&node.expr) {
                    // some exprs are allowed as statements, such as function calls or assignments
                    write_node(code, node, false, ctx)?;
                } else {
                    // inspect the type to see if a phony assignment is possible
                    // see https://www.w3.org/TR/WGSL/#phony-assignment-section
                    // quote: "T is constructible, a pointer type, a texture type, or a sampler type"
                    let phony_assignment_possible = match &node.ty {
                        t if t.is_constructible() => true,
                        Type::Ptr(..) => true,
                        Type::Store(StoreType::Handle(HandleType::SampledTexture { .. })) => true,
                        Type::Store(StoreType::Handle(HandleType::StorageTexture { .. })) => true,
                        Type::Store(StoreType::Handle(HandleType::Sampler(_))) => true,
                        _ => false,
                    };

                    if phony_assignment_possible {
                        write!(code, "_ = ")?;
                        write_node(code, node, false, ctx)?;
                    } else {
                        return Err(WgslErrorKind::ExprCannotBeAStatement(node.expr.clone())
                            .at_level(call_info, WgslErrorLevel::InternalPleaseReport));
                    }
                }
                code.write_str(suffix)?;
            }
            ExprStmt::IntroduceIdent(init) => {
                let init = &ctx.ctx.pool()[*init];

                let Some(ident) = init.ident else {
                    return Err(WgslErrorKind::MissingIdent("value binding")
                        .at_level(call_info, WgslErrorLevel::InternalPleaseReport));
                };

                write!(code, "let {}: ", &ctx.idents[ident])?;
                // write type in let to have more precise shader compiler errors in case shame has a bug
                write_type(code, init.call_info, init.ty(), ctx)?;
                write!(code, " = ")?;
                let ignore_ident = true; // this is the statement that gives the expression its ident.
                write_node(code, init, ignore_ident, ctx)?;
                code.write_str(suffix)?;
            }
            ExprStmt::Condition(node) => write_node_by_key(code, *node, false, ctx)?,
        },
        Stmt::Allocate(AllocStmt {
            allocation: region,
            initial_value,
        }) => {
            let Some(ident) = region.ident else {
                return Err(WgslErrorKind::MissingIdent("var definition")
                    .at_level(call_info, WgslErrorLevel::InternalPleaseReport));
            };

            let addr_sp = region.address_space;
            let store_ty = &region.ty;
            match initial_value {
                Some(node) => {
                    write!(code, "var {}: ", &ctx.idents[ident])?;
                    write_store_type(code, store_ty, call_info, ctx)?;
                    write!(code, " = ");
                    write_node_by_key(code, *node, false, ctx)?;
                    code.write_str(suffix)?;
                }
                None => {
                    // if the variable is in function address space, it needs a `var ident: ty;` decl,
                    // otherwise that decl was already written in the module scope

                    // see https://www.w3.org/TR/WGSL/#var-decls
                    if addr_sp == AddressSpace::Function {
                        write!(code, "var {}: ", &ctx.idents[ident])?;
                        write_store_type(code, store_ty, call_info, ctx)?;
                        code.write_str(suffix)?;
                    } else {
                        // comment signaling positioning of the var alloc in control flow
                        // even though the actual decl is in module scope already
                        write!(code, "/* var<_> {}: ", &ctx.idents[ident])?;
                        write_store_type(code, store_ty, call_info, ctx)?;
                        write!(code, " = <no init> */")?;
                    }
                }
            }
        }
        Stmt::Flow(flow, _) => match flow {
            FlowStmt::Control(control) => write_control_structure(code, control, ctx)?,
            FlowStmt::Jump(jump) => match jump {
                Jump::Continue => write!(code, "continue{suffix}")?,
                Jump::Break => write!(code, "break{suffix}")?,
                Jump::Return(node) => {
                    write!(code, "return")?;
                    if let Some(node) = node {
                        write!(code, " ")?;
                        write_node_by_key(code, *node, false, ctx)?
                    }
                    code.write_str(suffix)?;
                }
                Jump::Discard => write!(code, "discard{suffix}")?,
            },
        },
    }
    Ok(())
}

fn write_control_structure(
    code: &mut CodeWriteSpan,
    control_structure: &Control,
    ctx: &WgslContext,
) -> Result<(), WgslError> {
    let indent = ctx.indent.current();

    // StageMask::all() because it is no longer the entry-point block, which is the
    // only block that requires stage filtering. For any other block the filtering
    // has already happened further up in the write_* stack trace.
    let stage_mask = StageMask::all();

    match control_structure {
        Control::IfThen { cond, then } => {
            write!(code, "if ")?;
            write_block_by_key(code, *cond, StageMask::all(), ctx)?;
            write!(code, " ")?;
            write_block_by_key(code, *then, StageMask::all(), ctx)?;
        }
        Control::IfThenElse { cond, then, els } => {
            write!(code, "if ")?;
            write_block_by_key(code, *cond, StageMask::all(), ctx)?;
            write!(code, " ")?;
            write_block_by_key(code, *then, StageMask::all(), ctx)?;
            write!(code, " else ")?;
            write_block_by_key(code, *els, StageMask::all(), ctx)?;
        }
        Control::For { init, cond, inc, body } => {
            write!(code, "for (")?;
            write_block_by_key(code, *init, StageMask::all(), ctx)?;
            write!(code, "; ")?;
            write_block_by_key(code, *cond, StageMask::all(), ctx)?;
            write!(code, "; ")?;
            write_block_by_key(code, *inc, StageMask::all(), ctx)?;
            write!(code, ") ")?;
            write_block_by_key(code, *body, StageMask::all(), ctx)?;
        }
        Control::While { cond, body } => {
            write!(code, "while ")?;
            write_block_by_key(code, *cond, StageMask::all(), ctx)?;
            write!(code, " ")?;
            write_block_by_key(code, *body, StageMask::all(), ctx)?;
        }
    }
    Ok(())
}

fn write_fn_def(code: &mut CodeWriteSpan, func: &FunctionDef, ctx: &WgslContext) -> Result<(), WgslError> {
    let nodes = ctx.ctx.pool();
    let call_info = func.call_info;
    let mut code = code.sub_span(call_info);
    write!(&mut code, "fn {}(", &ctx.idents[func.ident])?;
    for (i, arg) in func.params.iter().map(|k| &nodes[*k]).enumerate() {
        if i != 0 {
            write!(code, ", ")?;
        }
        code.write_str(match arg.ident {
            Some(ident) => Ok(&ctx.idents[ident]),
            None => Err(
                WgslErrorKind::NthFunctionArgHasNoIdent(i as u32, ctx.idents[func.ident].to_string())
                    .at_level(call_info, WgslErrorLevel::InternalPleaseReport),
            ),
        }?)?;
        write!(&mut code, ": ")?;
        write_type(&mut code, call_info, &arg.ty, ctx)?;
    }
    write!(&mut code, ")")?;
    if let Some(return_ty) = func.return_.map(|r| &nodes[r].ty) {
        write!(&mut code, " -> ")?;
        write_type(&mut code, call_info, return_ty, ctx)?;
    }
    write!(&mut code, " ")?;
    write_block_by_key(&mut code, func.body, StageMask::all(), ctx)?;
    writeln!(&mut code)?;
    Ok(())
}

fn write_binding_def(
    code: &mut CodeWriteSpan,
    path: &BindPath,
    binding_info: &WipBinding,
    ctx: &WgslContext,
) -> Result<(), WgslError> {
    // TODO(release) test what happens if you generate a shared vertex/fragment
    // shader code string that declares a binding that has NO visibility for the fragment stage,
    // and is also not used in the fragment shader, but it still is declared
    let WipBinding {
        user_defined_visibility: _,
        binding_ty: bind_ty,
        shader_ty: store_ty,
        call_info,
        node: _,
    } = binding_info;
    let mut code = code.sub_span(*call_info);
    write!(code, "@group({}) @binding({}) ", path.0, path.1)?;
    write!(code, "var")?;
    match bind_ty {
        BindingType::Buffer { ty, has_dynamic_offset } => match ty {
            BufferBindingType::Uniform => write!(code, "<uniform>")?,
            BufferBindingType::Storage(access) => {
                write!(code, "<")?;
                write!(code, "storage, ")?;
                code.write_str(match access {
                    ir::AccessModeReadable::Read => "read",
                    ir::AccessModeReadable::ReadWrite => "read_write",
                })?;
                write!(code, ">")?;
            }
        },
        BindingType::Sampler(_) | BindingType::SampledTexture { .. } | BindingType::StorageTexture { .. } => (),
    }
    write!(code, " ")?;
    write_binding_ident(&mut code, *path, store_ty)?;
    write!(code, ": ")?;
    write_store_type(&mut code, store_ty, *call_info, ctx)?;
    writeln!(code, ";")?;
    Ok(())
}

fn write_push_constant_var_def(
    parent_span: &mut CodeWriteSpan,
    pc_info: &[WipPushConstantsField],
    ctx: &WgslContext,
) -> Result<(), WgslError> {
    // push constants have storage address space layout

    let [first, ..] = pc_info else { return Ok(()) };

    let mut code = parent_span.sub_span(first.call_info);
    writeln!(code, "var<push_constant> sm_pushc: sm_PushConstants;")?;
    writeln!(code, "struct sm_PushConstants {{");
    let indent = ctx.indent.deeper();
    for (i, field) in pc_info.iter().enumerate() {
        drop(code);
        code = parent_span.sub_span(field.call_info);
        write!(code, "{indent}")?;
        if let Some(size) = field.custom_min_size {
            write!(code, "@size({size}) ")?;
        }
        if let Some(align) = field.custom_min_align {
            write!(code, "@align({}) ", u32::from(align))?;
        }
        write!(code, "_{i}: ")?; // ident is made up on the spot, maybe we should give the user a way to give us ident info
        write_sized_type(&mut code, &field.ty, field.call_info, ctx)?;
        writeln!(code, ",")?;
    }
    drop(indent);
    writeln!(code, "}}");
    Ok(())
}

fn write_struct_definition(code: &mut CodeWriteSpan, def: &StructDef, ctx: &WgslContext) -> Result<(), WgslError> {
    let mut code = code.sub_span(def.call_info());
    writeln!(code, "struct {} {{", &ctx.idents[def.ident()])?;
    {
        let indent = ctx.indent.deeper();
        for (ident, field) in def.fields() {
            write!(code, "{indent}")?;
            if let Some(align) = field.custom_min_align() {
                write!(code, "@align({}) ", u64::from(align))?;
            }
            if let Some(size) = field.custom_min_size() {
                write!(code, "@size({size}) ")?;
            }
            write!(code, "{}: ", &ctx.idents[*ident])?;
            write_store_type(&mut code, &field.ty(), def.call_info(), ctx)?;
            writeln!(code, ",")?;
        }
    }
    writeln!(code, "}}")?;

    Ok(())
}
